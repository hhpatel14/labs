:sectlinks:
:markup-in-source: verbatim,attributes,quotes
:OCP4_PASSWORD: %ocp4_password%
:CLUSTER_ADMIN_USER: %cluster_admin_user%
:CLUSTER_ADMIN_PASSWORD: %cluster_admin_password%
:APPS_URL: %apps_url%
:API_URL: %api_url%

== Backing up multiple namespaces

We backed up a single namespace using `--include-namespaces` flag from Velero CLI. This flag actually accepts a `stringArray`. We can backup multiple namespaces using the flag separating them by `,`.

In previous exercises, we restored two namespaces `nginx-example` and `mysql-persistent`. Let's use those apps to perform backup of multiple namespace.
In our source OCP 4 cluster terminal, we can see the app running:

[source,bash,role=execute]
----
oc get pods -n nginx-example
----

[source,subs="{markup-in-source}"]
--------------------------------------------------------------------------------
NAME                                READY   STATUS    RESTARTS   AGE
nginx-deployment-56b7785cc7-g8xfj   1/1     Running   0          2h
nginx-deployment-56b7785cc7-q824n   1/1     Running   0          2h
--------------------------------------------------------------------------------

Check that todo list Application is still running.
[source,bash,role=execute]
----
oc get pods -n mysql-persistent
----
[source,subs="{markup-in-source}"]
--------------------------------------------------------------------------------
NAME                     READY   STATUS      RESTARTS   AGE
mysql-5f55cd786d-pshzl   1/1     Running     0          1h
todolist-1-deploy        0/1     Completed   0          1h
todolist-1-jx9xb         1/1     Running     0          1h
--------------------------------------------------------------------------------

Let’s checkout the route to the applications user interfaces.

[source,bash,role=execute]
----
oc get route -n nginx-example
----
[source,bash,role=execute]
----
oc get route -n mysql-persistent
----
NOTE: You can also use links here to open application routes http://my-nginx-nginx-example.{APPS_URL}[nginx-app] and http://todolist-route-mysql-persistent.{APPS_URL}[todolist-app].

 Check that the routes are working correctly. Add a new activity to the todo-list app then proceed to the next section.

=== Using Velero to backup application namespaces

Let’s go ahead and create a backup of `nginx-example` and `mysql-persistent` namespace.
[source,bash,role=execute-2]
----
velero backup create two-ns-backup --include-namespaces nginx-example,mysql-persistent
----

You can check on the backup progress by running the following
[source,bash,role=execute]
----
velero backup describe two-ns-backup
----
When the backup `Phase:` is `Completed`., proceed to next section.

=== Viewing backup content in S3 storage
Backup content is stored in S3 storage in the specified content in the prefix location under folder backup inside the backup name's folder.

`<bucket>/<velero-prefix>/backups/<backup-name>/<backup-content>`

[source,bash,role=execute]
----
awsocs s3 ls migstorage/velero/backups/two-ns-backup/
----

=== About Velero CSI Snapshots
The backup we did of the two namespaces used CSI snapshot capability of Velero to create snapshot on AWS EBS using its CSI Driver.

The details were explained in the previous exercise 6.0.

The namespace mysql-persistent we backup earlier contained a persistent volume claim that has storage class `gp2-csi` so that the snapshot was created using the AWS EBS CSI Driver. However, nginx is a simple stateless app which does not have pvc. In this case, we will not take any volumesnapShot, and cluster resources from the namespace `nginx-example` will be restored from the S3 bucket.
View persistent volume claim in the namespace `mysql-persistent`.
[source,bash,role=execute]
----
oc get pvc -n mysql-persistent
----
View VolumeSnapshot taken.
[source,bash,role=execute]
----
NEWEST_VS_MYSQL=$(oc get volumesnapshot -n mysql-persistent --sort-by=.metadata.creationTimestamp -o name | tail -n 1)
oc get $NEWEST_VS_MYSQL -n mysql-persistent 

----
View VolumeSnapshotContent created.
[source,bash,role=execute]
----
MYSQL_VS_CONTENT_NAME=$(oc get $NEWEST_VS_MYSQL -n mysql-persistent -o go-template='{{.status.boundVolumeSnapshotContentName}}')
oc get volumesnapshotcontent $MYSQL_VS_CONTENT_NAME
----

This storage class has provisioner `ebs.csi.aws.com`
[source,bash,role=execute]
----
oc get storageclass gp2-csi
----

which is one of the CSI driver installed on the system
[source,bash,role=execute]
----
oc get csidrivers
----

CSI Snapshot is local to the cluster. In the future, a DataMover capability will be added to allow for moving snapshots to an external location.

=== Simulate a disaster
When the backup `Phase:` is `Completed`., we'll proceed to simulate a disaster by deleting the two namespaces.
[source,bash,role=execute]
----
oc delete ns mysql-persistent nginx-example
----

Check that the applications are no longer available.

NOTE: You can also use links here to open application routes http://my-nginx-nginx-example.{APPS_URL}[nginx-app] and http://todolist-route-mysql-persistent.{APPS_URL}[todolist-app].

When application is no longer available, proceed to next section.

=== Restoring deleted application
We can restore applications deleted earlier by restoring from the backup we created.
[source,bash,role=execute]
----
velero restore create two-ns-restore --from-backup two-ns-backup
----

We can check when the restore is completed by running the following. The restore is complete when `Phase:` is `Completed`.
[source,bash,role=execute]
----
velero restore describe two-ns-restore
----

Wait until pods become available.
[source,bash,role=execute]
----
oc get pods -n mysql-persistent
----
[source,bash,role=execute]
----
oc get pods -n nginx-example
----

Verify that the data you added earlier persisted in the restored application.

NOTE: You can also use links here to open application routes http://my-nginx-nginx-example.{APPS_URL}[nginx-app] and http://todolist-route-mysql-persistent.{APPS_URL}[todolist-app].